<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Arcade Arena ‚Äî Multiplayer</title>
  <meta name="description" content="Arcade Arena: multiplayer arcade games hosted on GitHub Pages (P2P WebRTC)." />
  <style>
    :root{
      --bg:#070812; --panel:#0f1224; --panel2:#0b0d1a;
      --txt:#e8ecff; --muted:#a9b0d9;
      --a:#7c5cff; --b:#00e5ff; --c:#00ff88; --d:#ff4d8d;
      --bad:#ff5a5a; --ok:#29ff9b;
      --border: rgba(255,255,255,.08);
      --shadow: 0 18px 60px rgba(0,0,0,.55);
      --radius: 18px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: radial-gradient(1200px 700px at 20% 10%, rgba(124,92,255,.25), transparent 60%),
                  radial-gradient(900px 600px at 90% 30%, rgba(0,229,255,.18), transparent 55%),
                  radial-gradient(900px 700px at 50% 100%, rgba(0,255,136,.12), transparent 60%),
                  var(--bg);
      color:var(--txt);
      overflow:hidden;
    }
    a{color:var(--b)}
    .wrap{
      height:100%;
      display:grid;
      grid-template-columns: 360px 1fr;
      gap:14px;
      padding:14px;
    }
    @media (max-width: 980px){
      body{overflow:auto}
      .wrap{grid-template-columns: 1fr; overflow:auto}
    }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
    }
    .side{padding:14px; display:flex; flex-direction:column; gap:12px}
    .brand{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding:12px 12px;
      background: linear-gradient(90deg, rgba(124,92,255,.22), rgba(0,229,255,.16), rgba(0,255,136,.12));
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.10);
    }
    .brand h1{font-size:16px; margin:0; letter-spacing:.4px}
    .pill{
      font-size:12px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.25);
      color: var(--muted);
      white-space:nowrap;
    }
    .section{
      padding:12px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.20);
    }
    .section h2{margin:0 0 10px; font-size:13px; color:var(--muted); font-weight:700; letter-spacing:.3px}
    label{font-size:12px; color:var(--muted)}
    input, select, button, textarea{
      width:100%;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(10,12,25,.65);
      color: var(--txt);
      padding: 10px 11px;
      outline:none;
      font-size: 14px;
    }
    input::placeholder, textarea::placeholder{color: rgba(232,236,255,.45)}
    .row{display:grid; grid-template-columns: 1fr 1fr; gap:10px}
    .row3{display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px}
    button{
      cursor:pointer;
      background: linear-gradient(180deg, rgba(124,92,255,.9), rgba(124,92,255,.55));
      border:1px solid rgba(255,255,255,.14);
      font-weight:800;
    }
    button.secondary{
      background: linear-gradient(180deg, rgba(0,229,255,.75), rgba(0,229,255,.35));
    }
    button.ghost{
      background: rgba(255,255,255,.06);
    }
    button.danger{
      background: linear-gradient(180deg, rgba(255,77,141,.9), rgba(255,77,141,.45));
    }
    button:disabled{opacity:.5; cursor:not-allowed}
    .hint{font-size:12px; color:rgba(232,236,255,.65); line-height:1.35}
    .kpi{
      display:flex; gap:8px; flex-wrap:wrap; align-items:center;
      font-size:12px; color:rgba(232,236,255,.72);
    }
    .dot{width:9px; height:9px; border-radius:999px; background: var(--bad); box-shadow:0 0 10px rgba(255,90,90,.5)}
    .dot.ok{background: var(--ok); box-shadow:0 0 10px rgba(41,255,155,.45)}
    .games{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .gameTile{
      padding:10px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.24);
      display:flex; flex-direction:column; gap:8px;
      min-height:120px;
    }
    .gameTile strong{font-size:14px}
    .gameTile small{color:rgba(232,236,255,.65); line-height:1.35}
    .tag{display:inline-flex; gap:6px; align-items:center; width:max-content}
    .tag span{
      font-size:11px; padding:4px 8px; border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color:rgba(232,236,255,.75);
    }
    .main{
      display:grid;
      grid-template-rows: auto 1fr auto;
    }
    .topbar{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding:12px 14px;
      border-bottom:1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.18);
    }
    .topbar .title{display:flex; flex-direction:column; gap:2px}
    .topbar h3{margin:0; font-size:14px}
    .topbar p{margin:0; font-size:12px; color:rgba(232,236,255,.65)}
    .stage{
      position:relative;
      display:grid;
      place-items:center;
      background: radial-gradient(700px 450px at 50% 20%, rgba(0,229,255,.10), transparent 60%),
                  radial-gradient(900px 650px at 50% 80%, rgba(124,92,255,.12), transparent 65%),
                  rgba(0,0,0,.12);
    }
    canvas{
      width:min(1120px, 96vw);
      height:auto;
      border-radius: 18px;
      border:1px solid rgba(255,255,255,.12);
      background: linear-gradient(180deg, rgba(0,0,0,.35), rgba(0,0,0,.55));
      box-shadow: 0 18px 70px rgba(0,0,0,.65);
      image-rendering: crisp-edges;
    }
    .bottombar{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      padding:12px 14px;
      border-top:1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.18);
      flex-wrap:wrap;
    }
    .controls{
      display:flex; gap:8px; flex-wrap:wrap;
      align-items:center;
      font-size:12px;
      color:rgba(232,236,255,.70);
    }
    .chip{
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      white-space:nowrap;
    }
    .toast{
      position:absolute;
      top:14px; left:50%;
      transform: translateX(-50%);
      padding:10px 12px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.55);
      color: rgba(232,236,255,.85);
      font-size:12px;
      pointer-events:none;
      opacity:0;
      transition: opacity .18s ease;
    }
    .toast.show{opacity:1}
    .chat{
      display:flex; flex-direction:column; gap:10px;
    }
    .chatlog{
      height:160px;
      overflow:auto;
      padding:10px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.25);
      font-size:12px;
      color: rgba(232,236,255,.80);
      line-height:1.35;
      white-space:pre-wrap;
    }
    .chatlog b{color: #fff}
    .mobilePad{
      display:none;
      gap:10px;
      align-items:center;
    }
    @media (max-width: 980px){
      .mobilePad{display:flex; width:100%}
      .mobilePad button{width:auto; flex:1; padding:12px}
    }
  </style>
</head>

<body>
  <div class="wrap">
    <aside class="card side">
      <div class="brand">
        <div>
          <h1>üéÆ Arcade Arena</h1>
          <div class="hint">Multiplayer on GitHub Pages (P2P WebRTC)</div>
        </div>
        <div class="pill" id="buildTag">v1.2</div>
      </div>

      <div class="section">
        <h2>Connection</h2>
        <div class="kpi" style="margin-bottom:10px">
          <span class="dot" id="connDot"></span>
          <span id="connText">offline</span>
          <span class="pill" id="myIdPill" title="Your Peer ID">id: ‚Ä¶</span>
        </div>

        <div class="row" style="margin-bottom:10px">
          <div>
            <label>Nickname</label>
            <input id="nick" placeholder="e.g. Jay" maxlength="16" />
          </div>
          <div>
            <label>Room token / link</label>
            <input id="room" placeholder="Paste host link or token" maxlength="120" />
          </div>
        </div>

        <div class="row3">
          <button id="btnHost">Host room</button>
          <button class="secondary" id="btnJoin">Join room</button>
          <button class="danger" id="btnLeave" disabled>Leave</button>
        </div>

        <p class="hint" style="margin:10px 0 0">
          Host generates a share-link in the address bar. Share it. Joining connects directly peer-to-peer.
        </p>
      </div>

      <div class="section">
        <h2>Games</h2>
        <div class="games">
          <div class="gameTile">
            <div style="display:flex; justify-content:space-between; align-items:center; gap:8px">
              <strong>Neon Pong</strong>
              <div class="tag"><span>2P</span><span>fast</span></div>
            </div>
            <small>Classic Pong, but spicy: dash, curve, and speed ramps.</small>
            <button class="ghost" data-game="pong" id="pickPong">Play</button>
          </div>

          <div class="gameTile">
            <div style="display:flex; justify-content:space-between; align-items:center; gap:8px">
              <strong>Astro Tag</strong>
              <div class="tag"><span>2P</span><span>chaos</span></div>
            </div>
            <small>Top-down tag in a neon arena. Grab the orb, become ‚Äúit‚Äù.</small>
            <button class="ghost" data-game="tag" id="pickTag">Play</button>
          </div>

          <div class="gameTile">
            <div style="display:flex; justify-content:space-between; align-items:center; gap:8px">
              <strong>Neon Racer</strong>
              <div class="tag"><span>2P</span><span>racing</span></div>
            </div>
            <small>Top-down racing. Boost (Space). First to 3 laps wins.</small>
            <button class="ghost" data-game="race" id="pickRace">Play</button>
          </div>

          <div class="gameTile">
            <div style="display:flex; justify-content:space-between; align-items:center; gap:8px">
              <strong>Party Roulette</strong>
              <div class="tag"><span>host</span><span>fun</span></div>
            </div>
            <small>Turns on random game rotation between rounds.</small>
            <button class="ghost" id="btnPartyTile">Toggle Party</button>
          </div>
        </div>

        <div class="row" style="margin-top:10px">
          <button class="ghost" id="btnReady">Ready</button>
          <button class="ghost" id="btnReset">Reset round</button>
        </div>

        <div class="row" style="margin-top:10px">
          <button class="secondary" id="btnParty">Party mode: OFF</button>
          <button class="ghost" id="btnRandom">Random game</button>
        </div>

        <p class="hint" style="margin:10px 0 0">
          Controls: <b>Pong</b> W/S or ‚Üë/‚Üì (Space dash) ‚Ä¢ <b>Tag</b> WASD/Arrows (Space dash) ‚Ä¢ <b>Racer</b> ‚Üë accelerate, ‚Üì brake, ‚Üê/‚Üí steer (Space boost)
        </p>
      </div>

      <div class="section chat">
        <h2>Chat</h2>
        <div class="chatlog" id="chatlog"></div>
        <div class="row">
          <input id="chatin" placeholder="Type‚Ä¶ (enter to send)" maxlength="120" />
          <button class="secondary" id="btnSend">Send</button>
        </div>
      </div>

      <div class="section">
        <h2>Tips</h2>
        <div class="hint">
          ‚Ä¢ Best experience: Chrome/Edge on desktop<br/>
          ‚Ä¢ If joining fails: both players refresh + try again<br/>
          ‚Ä¢ Host is Player 1, joiner is Player 2
        </div>
      </div>
    </aside>

    <main class="card main">
      <div class="topbar">
        <div class="title">
          <h3 id="gameTitle">Lobby</h3>
          <p id="gameSubtitle">Host a room or join one. Then pick a game.</p>
        </div>
        <div class="kpi">
          <span class="chip" id="roleChip">role: ‚Äî</span>
          <span class="chip" id="roomChip">room: ‚Äî</span>
          <span class="chip" id="peerChip">peer: ‚Äî</span>
          <span class="chip" id="pingChip">ping: ‚Äî</span>
          <span class="chip" id="partyChip">party: OFF</span>
        </div>
      </div>

      <div class="stage">
        <div class="toast" id="toast">Toast</div>
        <canvas id="cv" width="960" height="540"></canvas>
      </div>

      <div class="bottombar">
        <div class="controls" id="controlHelp">
          <span class="chip">Space = dash/boost</span>
          <span class="chip">R = ready</span>
          <span class="chip">Esc = leave room</span>
        </div>

        <div class="mobilePad" id="mobilePad">
          <button class="ghost" id="mLeft">‚óÄ</button>
          <button class="ghost" id="mUp">‚ñ≤</button>
          <button class="ghost" id="mDown">‚ñº</button>
          <button class="ghost" id="mRight">‚ñ∂</button>
          <button class="secondary" id="mDash">DASH</button>
        </div>
      </div>
    </main>
  </div>

  <!-- PeerJS (WebRTC) ‚Äî works from static GitHub Pages -->
  <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>

  <script>
  // =========================================================
  // Arcade Arena ‚Äî static multiplayer via PeerJS (WebRTC)
  // =========================================================

  // ---------- Helpers ----------
  const $ = (id) => document.getElementById(id);
  const clamp = (v,a,b) => Math.max(a, Math.min(b,v));
  const rand = (a,b) => a + Math.random()*(b-a);
  const now = () => performance.now();

  function makeCode(len=5){
    const chars = "ABCDEFGHJKMNPQRSTUVWXYZ23456789";
    let s="";
    for(let i=0;i<len;i++) s += chars[(Math.random()*chars.length)|0];
    return s;
  }

  function toast(msg){
    const t = $("toast");
    t.textContent = msg;
    t.classList.add("show");
    clearTimeout(toast._tm);
    toast._tm = setTimeout(()=>t.classList.remove("show"), 1600);
  }

  function logChat(line){
    const el = $("chatlog");
    el.textContent += (el.textContent ? "\n" : "") + line;
    el.scrollTop = el.scrollHeight;
  }

  // ---------- UI ----------
  const ui = {
    connDot: $("connDot"),
    connText: $("connText"),
    myIdPill: $("myIdPill"),
    nick: $("nick"),
    room: $("room"),
    btnHost: $("btnHost"),
    btnJoin: $("btnJoin"),
    btnLeave: $("btnLeave"),
    btnReady: $("btnReady"),
    btnReset: $("btnReset"),
    btnParty: $("btnParty"),
    btnRandom: $("btnRandom"),
    btnPartyTile: $("btnPartyTile"),
    btnSend: $("btnSend"),
    chatin: $("chatin"),
    gameTitle: $("gameTitle"),
    gameSubtitle: $("gameSubtitle"),
    roleChip: $("roleChip"),
    roomChip: $("roomChip"),
    peerChip: $("peerChip"),
    pingChip: $("pingChip"),
    partyChip: $("partyChip"),
    pickPong: $("pickPong"),
    pickTag: $("pickTag"),
    pickRace: $("pickRace"),
    mobilePad: $("mobilePad")
  };

  // ---------- Networking model ----------
  // Host = authoritative simulation, sends state snapshots to client.
  // Client sends inputs to host.
  let peer = null;
  let conn = null;     // DataConnection to other player
  let role = "none";   // "host" | "client" | "none"
  let roomCode = "";
  let myId = "";
  let peerId = "";
  let connected = false;

  // Ping
  let pingMs = null;

  // Lobby ready flags
  let ready = { host:false, client:false };

  // Current game selection
  let currentGame = "lobby"; // "pong" | "tag" | "race" | "lobby"
  let inRound = false;

  // Party mode
  let partyMode = false;
  const gamesList = ["pong", "tag", "race"];

  // Inputs for both players (host keeps both)
  const input = {
    host: { up:false, down:false, left:false, right:false, dash:false },
    client:{ up:false, down:false, left:false, right:false, dash:false }
  };

  // ---------- Canvas ----------
  const cv = $("cv");
  const ctx = cv.getContext("2d");

  // Background starfield
  const stars = Array.from({length:140}, ()=>({
    x: Math.random()*cv.width,
    y: Math.random()*cv.height,
    s: rand(0.6,2.2),
    v: rand(15,55)
  }));

  function drawBg(dt){
    ctx.save();
    ctx.clearRect(0,0,cv.width,cv.height);

    // stars
    ctx.globalAlpha = 0.8;
    ctx.fillStyle = "rgba(255,255,255,.95)";
    for(const st of stars){
      st.y += st.v * dt;
      if(st.y > cv.height+10){ st.y = -10; st.x = Math.random()*cv.width; }
      ctx.fillRect(st.x, st.y, st.s, st.s);
    }
    ctx.restore();
  }

  // ---------- Sound (tiny, optional) ----------
  let audioCtx = null;
  function beep(freq=440, ms=60, gain=0.03){
    try{
      if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = "sine";
      o.frequency.value = freq;
      g.gain.value = gain;
      o.connect(g); g.connect(audioCtx.destination);
      o.start();
      setTimeout(()=>{ o.stop(); }, ms);
    }catch(e){}
  }

  // =========================================================
  // Game: Neon Pong (2P)
  // =========================================================
  const Pong = (() => {
    const W = cv.width, H = cv.height;
    const state = {
      ball: { x: W/2, y: H/2, vx: 340, vy: 120, r: 9 },
      p1: { y: H/2, vy: 0, score: 0, dash: 0 },
      p2: { y: H/2, vy: 0, score: 0, dash: 0 },
      speed: 1.0,
      serveTo: 1,
      msg: "Press Ready",
    };

    function resetRound(){
      state.ball.x = W/2; state.ball.y = H/2;
      const dir = state.serveTo === 1 ? 1 : -1;
      state.ball.vx = dir * 340;
      state.ball.vy = rand(-160,160);
      state.speed = 1.0;
      state.msg = "GO!";
      beep(520,60,0.02);
    }

    function applyInput(dt, who, inp){
      const P = (who === 1) ? state.p1 : state.p2;
      const base = 420;
      let v = 0;
      if(inp.up) v -= base;
      if(inp.down) v += base;

      if(P.dash > 0) P.dash -= dt;
      if(inp.dash && P.dash <= 0){
        P.dash = 1.2;
        v *= 2.0;
        beep(760,45,0.02);
      }
      P.vy = v;
      P.y = clamp(P.y + P.vy*dt, 46, H-46);
    }

    function step(dt){
      const b = state.ball;
      b.x += b.vx * dt * state.speed;
      b.y += b.vy * dt * state.speed;

      if(b.y < 18){ b.y = 18; b.vy *= -1; beep(620,35,0.015); }
      if(b.y > H-18){ b.y = H-18; b.vy *= -1; beep(620,35,0.015); }

      const px = 40, pw = 12, ph = 90;
      const p1y = state.p1.y, p2y = state.p2.y;

      if(b.x - b.r < px+pw && b.x > px){
        if(Math.abs(b.y - p1y) < ph/2){
          b.x = px+pw + b.r;
          b.vx = Math.abs(b.vx) * 1.06;
          b.vy += (b.y - p1y) * 6.0;
          state.speed = clamp(state.speed + 0.02, 1, 1.55);
          beep(520,40,0.02);
        }
      }

      const rx = W - 40 - pw;
      if(b.x + b.r > rx && b.x < rx+pw){
        if(Math.abs(b.y - p2y) < ph/2){
          b.x = rx - b.r;
          b.vx = -Math.abs(b.vx) * 1.06;
          b.vy += (b.y - p2y) * 6.0;
          state.speed = clamp(state.speed + 0.02, 1, 1.55);
          beep(520,40,0.02);
        }
      }

      if(b.x < -40){
        state.p2.score++;
        state.serveTo = 1;
        state.msg = "Point ‚Üí Player 2";
        beep(220,120,0.03);
        resetRound();
      }
      if(b.x > W+40){
        state.p1.score++;
        state.serveTo = 2;
        state.msg = "Point ‚Üí Player 1";
        beep(220,120,0.03);
        resetRound();
      }
    }

    function draw(){
      ctx.save();
      ctx.globalAlpha = 0.9;

      ctx.strokeStyle = "rgba(255,255,255,.14)";
      ctx.setLineDash([10,12]);
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(W/2, 40);
      ctx.lineTo(W/2, H-40);
      ctx.stroke();
      ctx.setLineDash([]);

      ctx.strokeStyle = "rgba(124,92,255,.22)";
      ctx.lineWidth = 2;
      ctx.strokeRect(22, 22, W-44, H-44);

      const pw=12, ph=90, px=40, rx=W-40-pw;
      ctx.fillStyle = "rgba(0,229,255,.85)";
      ctx.fillRect(px, state.p1.y - ph/2, pw, ph);
      ctx.fillStyle = "rgba(0,255,136,.85)";
      ctx.fillRect(rx, state.p2.y - ph/2, pw, ph);

      ctx.fillStyle = "rgba(255,255,255,.92)";
      ctx.beginPath();
      ctx.arc(state.ball.x, state.ball.y, state.ball.r, 0, Math.PI*2);
      ctx.fill();

      ctx.globalAlpha = 1;
      ctx.fillStyle = "rgba(232,236,255,.9)";
      ctx.font = "700 28px ui-sans-serif, system-ui";
      ctx.fillText(state.p1.score, W/2 - 80, 64);
      ctx.fillText(state.p2.score, W/2 + 60, 64);

      ctx.font = "600 12px ui-sans-serif, system-ui";
      ctx.fillStyle = "rgba(232,236,255,.70)";
      ctx.fillText(state.msg, 36, H-22);

      ctx.restore();
    }

    function serialize(){ return JSON.parse(JSON.stringify(state)); }
    function load(s){ Object.assign(state, s); }

    return { state, resetRound, applyInput, step, draw, serialize, load };
  })();

  // =========================================================
  // Game: Astro Tag (2P)
  // =========================================================
  const Tag = (() => {
    const W = cv.width, H = cv.height;
    const state = {
      p1: { x: W*0.25, y: H*0.5, vx:0, vy:0, score:0, dash:0 },
      p2: { x: W*0.75, y: H*0.5, vx:0, vy:0, score:0, dash:0 },
      orb: { x: W/2, y: H/2, t:0 },
      it: 1,
      msg: "Press Ready",
      roundT: 0,
    };

    const obstacles = [
      {x: W/2 - 110, y: H/2 - 22, w: 220, h: 44},
      {x: W/2 - 22, y: H/2 - 150, w: 44,  h: 300},
    ];

    function resetRound(){
      state.p1.x = W*0.25; state.p1.y = H*0.5; state.p1.vx=0; state.p1.vy=0; state.p1.dash=0;
      state.p2.x = W*0.75; state.p2.y = H*0.5; state.p2.vx=0; state.p2.vy=0; state.p2.dash=0;
      state.orb.x = W/2; state.orb.y = H/2; state.orb.t = 0;
      state.it = (Math.random()<0.5)?1:2;
      state.msg = "GO! Grab the orb";
      state.roundT = 0;
      beep(620,70,0.02);
    }

    function pushOutRect(p, r){
      if(p.x > r.x && p.x < r.x+r.w && p.y > r.y && p.y < r.y+r.h){
        const left = p.x - r.x, right = (r.x+r.w) - p.x;
        const top = p.y - r.y, bottom = (r.y+r.h) - p.y;
        const m = Math.min(left,right,top,bottom);
        if(m === left) p.x = r.x - 0.01;
        else if(m === right) p.x = r.x+r.w + 0.01;
        else if(m === top) p.y = r.y - 0.01;
        else p.y = r.y+r.h + 0.01;
      }
    }

    function applyInput(dt, who, inp){
      const P = who===1 ? state.p1 : state.p2;
      const base = 300;
      let ax=0, ay=0;
      if(inp.left) ax -= 1;
      if(inp.right) ax += 1;
      if(inp.up) ay -= 1;
      if(inp.down) ay += 1;

      const mag = Math.hypot(ax,ay) || 1;
      ax/=mag; ay/=mag;

      if(P.dash>0) P.dash -= dt;
      let sp = base;
      if(inp.dash && P.dash<=0){
        P.dash = 1.1;
        sp = 560;
        beep(760,45,0.02);
      }

      P.vx = ax * sp;
      P.vy = ay * sp;

      P.x = clamp(P.x + P.vx*dt, 26, W-26);
      P.y = clamp(P.y + P.vy*dt, 26, H-26);

      for(const r of obstacles) pushOutRect(P, r);
    }

    function step(dt){
      state.roundT += dt;

      state.orb.t += dt;
      state.orb.x = W/2 + Math.cos(state.orb.t*1.2)*140;
      state.orb.y = H/2 + Math.sin(state.orb.t*1.6)*90;

      const p1 = state.p1, p2 = state.p2, o = state.orb;

      const d12 = Math.hypot(p1.x-p2.x, p1.y-p2.y);
      if(d12 < 28){
        state.it = (state.it===1)?2:1;
        state.msg = `TAG! Player ${state.it} is IT`;
        beep(520,60,0.02);
      }

      const itP = state.it===1 ? p1 : p2;
      const dOrb = Math.hypot(itP.x - o.x, itP.y - o.y);
      if(dOrb < 22){
        if(state.it===1) state.p1.score += dt*10;
        else state.p2.score += dt*10;
        if(Math.random() < 0.04) beep(980,25,0.01);
      }

      if(state.p1.score >= 100 || state.p2.score >= 100){
        const w = state.p1.score >= 100 ? 1 : 2;
        state.msg = `WINNER: Player ${w}  (Reset round)`;
        inRound = false;
        beep(220,180,0.04);
      }
    }

    function draw(){
      ctx.save();
      ctx.globalAlpha = 0.95;

      ctx.strokeStyle = "rgba(0,229,255,.18)";
      ctx.lineWidth = 2;
      ctx.strokeRect(18,18, W-36, H-36);

      ctx.fillStyle = "rgba(255,255,255,.07)";
      for(const r of obstacles) ctx.fillRect(r.x, r.y, r.w, r.h);

      ctx.fillStyle = "rgba(255,77,141,.85)";
      ctx.beginPath();
      ctx.arc(state.orb.x, state.orb.y, 10, 0, Math.PI*2);
      ctx.fill();

      function drawP(P, color, isIt){
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(P.x, P.y, 14, 0, Math.PI*2);
        ctx.fill();
        if(isIt){
          ctx.strokeStyle = "rgba(255,255,255,.85)";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(P.x, P.y, 19, 0, Math.PI*2);
          ctx.stroke();
        }
      }
      drawP(state.p1, "rgba(0,229,255,.85)", state.it===1);
      drawP(state.p2, "rgba(0,255,136,.85)", state.it===2);

      ctx.globalAlpha = 1;
      ctx.fillStyle = "rgba(232,236,255,.9)";
      ctx.font = "700 18px ui-sans-serif, system-ui";
      ctx.fillText(`P1: ${Math.floor(state.p1.score)}`, 26, 44);
      ctx.fillText(`P2: ${Math.floor(state.p2.score)}`, W-140, 44);

      ctx.font = "600 12px ui-sans-serif, system-ui";
      ctx.fillStyle = "rgba(232,236,255,.70)";
      ctx.fillText(state.msg, 26, H-22);

      ctx.restore();
    }

    function serialize(){ return JSON.parse(JSON.stringify(state)); }
    function load(s){ Object.assign(state, s); }

    return { state, resetRound, applyInput, step, draw, serialize, load };
  })();

  // =========================================================
  // Game: Neon Racer (2P)
  // =========================================================
  const Race = (() => {
    const W = cv.width, H = cv.height;

    const track = {
      outer: { x: 50, y: 50, w: W-100, h: H-100 },
      inner: { x: 230, y: 140, w: W-460, h: H-280 },
      start: { x: 120, y: 160, w: 6, h: H-320 },
      bumpers: [
        { x: W/2 - 18, y: 90, w: 36, h: 140 },
        { x: W/2 - 18, y: H-230, w: 36, h: 140 },
        { x: W/2 - 160, y: H/2 - 18, w: 140, h: 36 },
        { x: W/2 + 20,  y: H/2 - 18, w: 140, h: 36 },
      ]
    };

    const state = {
      p1: makeCar(1, 150, H/2 - 40, 0),
      p2: makeCar(2, 150, H/2 + 40, 0),
      lapsToWin: 3,
      msg: "Press Ready",
      winner: 0
    };

    function makeCar(id, x, y, a){
      return { id, x, y, a, v: 0, vx: 0, vy: 0, lap: 0, lastCross: 0, boostCd: 0 };
    }

    function resetRound(){
      state.p1 = makeCar(1, 150, H/2 - 40, 0);
      state.p2 = makeCar(2, 150, H/2 + 40, 0);
      state.msg = "GO! 3 laps to win";
      state.winner = 0;
      beep(620,70,0.02);
    }

    function rectContains(r, x, y){
      return x >= r.x && x <= r.x+r.w && y >= r.y && y <= r.y+r.h;
    }

    function inWall(x, y){
      const o = rectContains(track.outer, x, y);
      const i = rectContains(track.inner, x, y);
      return (!o) || i || track.bumpers.some(b => rectContains(b, x, y));
    }

    function applyInput(dt, car, inp){
      const accel = 520;
      const brake = 680;
      const maxV = 520;
      const steer = 3.1;
      const drift = 0.85;

      if(car.boostCd > 0) car.boostCd -= dt;

      if(inp.up) car.v += accel * dt;
      if(inp.down) car.v -= brake * dt;

      car.v = clamp(car.v, -220, maxV);
      car.v *= (1 - 0.8*dt);

      const speedFactor = clamp(Math.abs(car.v)/300, 0, 1);
      const turn = steer * speedFactor;
      if(inp.left) car.a -= turn * dt;
      if(inp.right) car.a += turn * dt;

      if(inp.dash && car.boostCd <= 0){
        car.boostCd = 1.2;
        car.v += 240;
        beep(760,45,0.02);
      }

      const fx = Math.cos(car.a) * car.v;
      const fy = Math.sin(car.a) * car.v;

      car.vx = car.vx*drift + fx*(1-drift);
      car.vy = car.vy*drift + fy*(1-drift);

      const nx = car.x + car.vx*dt;
      const ny = car.y + car.vy*dt;

      if(inWall(nx, ny)){
        car.v *= 0.45;
        car.vx *= -0.3;
        car.vy *= -0.3;
        beep(320,40,0.02);
      }else{
        car.x = nx;
        car.y = ny;
      }

      car.x = clamp(car.x, 20, W-20);
      car.y = clamp(car.y, 20, H-20);
    }

    function carBump(){
      const a = state.p1, b = state.p2;
      const dx = b.x - a.x, dy = b.y - a.y;
      const d = Math.hypot(dx,dy);
      if(d < 28){
        const nx = dx/(d||1), ny = dy/(d||1);
        a.x -= nx*8; a.y -= ny*8;
        b.x += nx*8; b.y += ny*8;
        const tmpvx = a.vx, tmpvy = a.vy;
        a.vx = b.vx*0.9; a.vy = b.vy*0.9;
        b.vx = tmpvx*0.9; b.vy = tmpvy*0.9;
        beep(520,25,0.015);
      }
    }

    function lapLogic(car){
      const r = track.start;
      const onLine = rectContains(r, car.x, car.y);
      if(onLine && car.lastCross === 0){
        const forwardX = Math.cos(car.a);
        if(forwardX < -0.15){
          car.lap += 1;
          car.lastCross = 1;
          beep(980,40,0.02);
        }
      }
      if(!onLine) car.lastCross = 0;
    }

    function step(dt){
      if(state.winner) return;

      lapLogic(state.p1);
      lapLogic(state.p2);

      if(state.p1.lap >= state.lapsToWin) state.winner = 1;
      if(state.p2.lap >= state.lapsToWin) state.winner = 2;

      if(state.winner){
        state.msg = `WINNER: Player ${state.winner}  (Reset round)`;
        inRound = false;
        beep(220,180,0.04);
      }
    }

    function drawTrack(){
      ctx.save();

      ctx.strokeStyle = "rgba(0,229,255,.18)";
      ctx.lineWidth = 2;
      ctx.strokeRect(track.outer.x, track.outer.y, track.outer.w, track.outer.h);

      ctx.strokeStyle = "rgba(124,92,255,.18)";
      ctx.strokeRect(track.inner.x, track.inner.y, track.inner.w, track.inner.h);

      ctx.fillStyle = "rgba(255,255,255,.07)";
      for(const b of track.bumpers) ctx.fillRect(b.x, b.y, b.w, b.h);

      ctx.fillStyle = "rgba(255,77,141,.7)";
      ctx.fillRect(track.start.x, track.start.y, track.start.w, track.start.h);

      ctx.fillStyle = "rgba(232,236,255,.12)";
      for(let y = track.start.y; y < track.start.y+track.start.h; y += 26){
        ctx.fillRect(track.start.x+12, y, 18, 4);
      }

      ctx.restore();
    }

    function drawCar(car, color, isLead){
      ctx.save();
      ctx.translate(car.x, car.y);
      ctx.rotate(car.a);

      ctx.fillStyle = color;
      ctx.fillRect(-14, -9, 28, 18);

      ctx.fillStyle = "rgba(0,0,0,.35)";
      ctx.fillRect(-3, -6, 10, 12);

      ctx.fillStyle = "rgba(255,255,255,.85)";
      ctx.fillRect(10, -3, 6, 6);

      if(isLead){
        ctx.strokeStyle = "rgba(255,255,255,.70)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0,0, 20, 0, Math.PI*2);
        ctx.stroke();
      }

      ctx.restore();
    }

    function draw(){
      ctx.save();
      drawTrack();

      const lead =
        (state.p1.lap !== state.p2.lap) ? (state.p1.lap > state.p2.lap ? 1 : 2) :
        (state.p1.x < state.p2.x ? 1 : 2);

      drawCar(state.p1, "rgba(0,229,255,.85)", lead===1);
      drawCar(state.p2, "rgba(0,255,136,.85)", lead===2);

      ctx.fillStyle = "rgba(232,236,255,.9)";
      ctx.font = "700 18px ui-sans-serif, system-ui";
      ctx.fillText(`P1 Laps: ${state.p1.lap}/${state.lapsToWin}`, 26, 44);
      ctx.fillText(`P2 Laps: ${state.p2.lap}/${state.lapsToWin}`, W-190, 44);

      ctx.font = "600 12px ui-sans-serif, system-ui";
      ctx.fillStyle = "rgba(232,236,255,.70)";
      ctx.fillText(state.msg, 26, H-22);

      ctx.restore();
    }

    function serialize(){ return JSON.parse(JSON.stringify(state)); }
    function load(s){ Object.assign(state, s); }

    return {
      state,
      resetRound,
      applyInput: (dt, who, inp) => applyInput(dt, who===1 ? state.p1 : state.p2, inp),
      bump: carBump,
      step,
      draw,
      serialize,
      load
    };
  })();

  // =========================================================
  // Game Loop + State Sync
  // =========================================================
  let lastT = now();
  requestAnimationFrame(loop);

  function loop(){
    const t = now();
    let dt = (t - lastT) / 1000;
    lastT = t;
    dt = clamp(dt, 0, 1/20);

    drawBg(dt);

    if(currentGame === "lobby"){
      drawLobby();
    }else{
      // Host simulates
      if(role === "host" && connected && inRound){
        if(currentGame === "pong"){
          Pong.applyInput(dt, 1, input.host);
          Pong.applyInput(dt, 2, input.client);
          Pong.step(dt);
        }else if(currentGame === "tag"){
          Tag.applyInput(dt, 1, input.host);
          Tag.applyInput(dt, 2, input.client);
          Tag.step(dt);
        }else if(currentGame === "race"){
          Race.applyInput(dt, 1, input.host);
          Race.applyInput(dt, 2, input.client);
          Race.bump();
          Race.step(dt);
        }
        sendStateMaybe(t);
      }

      if(currentGame === "pong") Pong.draw();
      if(currentGame === "tag") Tag.draw();
      if(currentGame === "race") Race.draw();

      if(!inRound){
        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,.45)";
        ctx.fillRect(0,0,cv.width,cv.height);
        ctx.fillStyle = "rgba(232,236,255,.92)";
        ctx.font = "800 28px ui-sans-serif, system-ui";
        ctx.textAlign = "center";
        ctx.fillText("READY UP", cv.width/2, cv.height/2 - 10);
        ctx.font = "600 14px ui-sans-serif, system-ui";
        ctx.fillStyle = "rgba(232,236,255,.75)";
        ctx.fillText("Click Ready (or press R). Both players must be ready.", cv.width/2, cv.height/2 + 18);
        ctx.restore();
      }
    }

    requestAnimationFrame(loop);
  }

  function drawLobby(){
    ctx.save();
    ctx.globalAlpha = 1;
    ctx.fillStyle = "rgba(232,236,255,.9)";
    ctx.font = "900 40px ui-sans-serif, system-ui";
    ctx.textAlign = "center";
    ctx.fillText("ARCADE ARENA", cv.width/2, 170);

    ctx.font = "600 16px ui-sans-serif, system-ui";
    ctx.fillStyle = "rgba(232,236,255,.70)";
    ctx.fillText("Host a room or join one. Then pick a game.", cv.width/2, 205);

    const k = (now()/1000);
    ctx.strokeStyle = "rgba(124,92,255,.35)";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(cv.width/2, 300, 90 + Math.sin(k*1.2)*6, 0, Math.PI*2);
    ctx.stroke();

    ctx.strokeStyle = "rgba(0,229,255,.28)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(cv.width/2, 300, 118 + Math.cos(k*1.1)*6, 0, Math.PI*2);
    ctx.stroke();

    ctx.font = "700 13px ui-sans-serif, system-ui";
    ctx.fillStyle = "rgba(232,236,255,.65)";
    ctx.fillText("Tip: host shares the link from the address bar.", cv.width/2, 430);

    ctx.restore();
  }

  // Host sends snapshots at ~30Hz
  let lastSend = 0;
  function sendStateMaybe(tMs){
    if(!conn || !conn.open) return;
    if(tMs - lastSend < 33) return;
    lastSend = tMs;

    const payload = {
      type:"state",
      game: currentGame,
      inRound,
      ready,
      partyMode,
      t: Date.now(),
      s: currentGame==="pong" ? Pong.serialize()
        : currentGame==="tag" ? Tag.serialize()
        : Race.serialize()
    };
    conn.send(payload);
  }

  function setGame(game){
    currentGame = game;
    inRound = false;
    ready.host = false; ready.client = false;

    if(game === "lobby"){
      ui.gameTitle.textContent = "Lobby";
      ui.gameSubtitle.textContent = "Host a room or join one. Then pick a game.";
      return;
    }
    if(game === "pong"){
      ui.gameTitle.textContent = "Neon Pong";
      ui.gameSubtitle.textContent = "Dash (Space). Curve by hitting off-center.";
      Pong.state.msg = "Press Ready";
    }
    if(game === "tag"){
      ui.gameTitle.textContent = "Astro Tag";
      ui.gameSubtitle.textContent = "Be IT, touch orb to score. Touch opponent to tag.";
      Tag.state.msg = "Press Ready";
    }
    if(game === "race"){
      ui.gameTitle.textContent = "Neon Racer";
      ui.gameSubtitle.textContent = "‚Üë accelerate, ‚Üì brake, ‚Üê/‚Üí steer, Space boost.";
      Race.state.msg = "Press Ready";
    }

    send({ type:"pick", game });
  }

  function startRoundIfReady(){
    if(!(ready.host && ready.client)) return;
    inRound = true;

    if(role === "host"){
      if(currentGame === "pong") Pong.resetRound();
      if(currentGame === "tag") Tag.resetRound();
      if(currentGame === "race") Race.resetRound();
      send({ type:"round", action:"start", game: currentGame });
    }
  }

  function resetRound(){
    // Party rotate BEFORE resetting (host chooses and syncs)
    if(role === "host" && partyMode){
      const g = gamesList[(Math.random()*gamesList.length)|0];
      setGame(g);
    }

    inRound = false;
    ready.host = false; ready.client = false;

    if(role === "host"){
      if(currentGame === "pong") Pong.resetRound();
      if(currentGame === "tag") Tag.resetRound();
      if(currentGame === "race") Race.resetRound();
      send({ type:"round", action:"reset", game: currentGame });
    }else{
      send({ type:"round", action:"reset_req", game: currentGame });
    }
  }

  // =========================================================
  // PeerJS setup
  // =========================================================
  function initPeer(){
    if(peer) { try{ peer.destroy(); }catch(e){} }
    peer = new Peer(undefined, { debug: 0 });

    peer.on("open", id => {
      myId = id;
      ui.myIdPill.textContent = `id: ${id.slice(0,6)}‚Ä¶`;
      ui.connText.textContent = "online (not in room)";
      ui.connDot.classList.add("ok");
    });

    peer.on("connection", c => {
      if(conn && conn.open){
        c.close();
        return;
      }
      role = "host";
      attachConn(c);
      toast("Player joined your room!");
      logChat("‚Ä¢ System: player joined.");
    });

    peer.on("disconnected", () => {
      ui.connText.textContent = "offline";
      ui.connDot.classList.remove("ok");
    });

    peer.on("error", err => {
      console.warn(err);
      toast("Network error. Refresh and try again.");
    });
  }

  initPeer();

  function attachConn(c){
    conn = c;
    connected = true;
    peerId = c.peer;

    ui.btnLeave.disabled = false;
    ui.btnHost.disabled = true;
    ui.btnJoin.disabled = true;

    ui.roleChip.textContent = `role: ${role}`;
    ui.roomChip.textContent = `room: ${roomCode || "‚Äî"}`;
    ui.peerChip.textContent = `peer: ${peerId.slice(0,6)}‚Ä¶`;
    ui.connText.textContent = "connected";
    ui.connDot.classList.add("ok");

    send({ type:"hello", nick: ui.nick.value || "Player", room: roomCode, partyMode });

    c.on("data", onData);
    c.on("open", () => {
      pingLoop();
      toast("Connected!");
      beep(660,70,0.02);
    });
    c.on("close", () => {
      onLeaveCleanup();
      toast("Peer disconnected");
    });
    c.on("error", () => {
      onLeaveCleanup();
      toast("Peer connection error");
    });
  }

  function onLeaveCleanup(){
    connected = false;
    peerId = "";
    roomCode = "";
    role = "none";
    conn = null;

    ui.btnLeave.disabled = true;
    ui.btnHost.disabled = false;
    ui.btnJoin.disabled = false;

    ui.roleChip.textContent = "role: ‚Äî";
    ui.roomChip.textContent = "room: ‚Äî";
    ui.peerChip.textContent = "peer: ‚Äî";
    ui.pingChip.textContent = "ping: ‚Äî";

    ready.host=false; ready.client=false;
    inRound=false;
    setGame("lobby");
    logChat("‚Ä¢ System: disconnected.");
  }

  function send(obj){
    if(conn && conn.open){
      conn.send(obj);
    }
  }

  function onData(msg){
    if(!msg || typeof msg !== "object") return;

    if(msg.type === "hello"){
      logChat(`‚Ä¢ System: connected with ${msg.nick || "Player"}`);
      if(typeof msg.partyMode === "boolean"){
        partyMode = msg.partyMode;
        ui.partyChip.textContent = `party: ${partyMode ? "ON" : "OFF"}`;
        ui.btnParty.textContent = `Party mode: ${partyMode ? "ON" : "OFF"}`;
      }
      if(role === "host"){
        send({ type:"pick", game: currentGame });
        send({ type:"ready", who:"host", v: ready.host });
        send({ type:"party", v: partyMode });
      }
      return;
    }

    if(msg.type === "chat"){
      logChat(`‚Ä¢ ${msg.nick || "Player"}: ${msg.text}`);
      return;
    }

    if(msg.type === "party"){
      partyMode = !!msg.v;
      ui.partyChip.textContent = `party: ${partyMode ? "ON" : "OFF"}`;
      ui.btnParty.textContent = `Party mode: ${partyMode ? "ON" : "OFF"}`;
      toast(`Party mode ${partyMode ? "ON" : "OFF"}`);
      return;
    }

    if(msg.type === "pick"){
      currentGame = msg.game;
      ready.host=false; ready.client=false; inRound=false;

      if(currentGame==="pong"){
        ui.gameTitle.textContent="Neon Pong";
        ui.gameSubtitle.textContent="Dash (Space). Curve by hitting off-center.";
      }else if(currentGame==="tag"){
        ui.gameTitle.textContent="Astro Tag";
        ui.gameSubtitle.textContent="Be IT, touch orb to score. Touch opponent to tag.";
      }else if(currentGame==="race"){
        ui.gameTitle.textContent="Neon Racer";
        ui.gameSubtitle.textContent="‚Üë accelerate, ‚Üì brake, ‚Üê/‚Üí steer, Space boost.";
      }else{
        ui.gameTitle.textContent="Lobby";
        ui.gameSubtitle.textContent="Host a room or join one. Then pick a game.";
      }
      toast(`Game set: ${currentGame}`);
      return;
    }

    if(msg.type === "ready"){
      if(msg.who === "host") ready.host = !!msg.v;
      if(msg.who === "client") ready.client = !!msg.v;
      if(role === "host") startRoundIfReady();
      return;
    }

    if(msg.type === "round"){
      if(msg.action === "start"){
        inRound = true;
        toast("Round started!");
      }
      if(msg.action === "reset"){
        inRound = false;
        ready.host=false; ready.client=false;
        toast("Round reset");
      }
      if(msg.action === "reset_req"){
        if(role === "host") resetRound();
      }
      return;
    }

    if(msg.type === "input"){
      if(role === "host"){
        input.client = msg.v;
      }
      return;
    }

    if(msg.type === "state"){
      if(role === "client"){
        currentGame = msg.game;
        inRound = !!msg.inRound;
        ready = msg.ready || ready;
        if(typeof msg.partyMode === "boolean"){
          partyMode = msg.partyMode;
          ui.partyChip.textContent = `party: ${partyMode ? "ON" : "OFF"}`;
          ui.btnParty.textContent = `Party mode: ${partyMode ? "ON" : "OFF"}`;
        }
        if(currentGame === "pong") Pong.load(msg.s);
        if(currentGame === "tag") Tag.load(msg.s);
        if(currentGame === "race") Race.load(msg.s);
      }
      return;
    }

    if(msg.type === "ping"){
      send({ type:"pong", t: msg.t });
      return;
    }
    if(msg.type === "pong"){
      const rtt = Date.now() - msg.t;
      pingMs = rtt;
      ui.pingChip.textContent = `ping: ${rtt}ms`;
      return;
    }
  }

  function pingLoop(){
    if(!connected) return;
    send({ type:"ping", t: Date.now() });
    setTimeout(pingLoop, 1200);
  }

  // =========================================================
  // UI Actions
  // =========================================================
  ui.btnHost.onclick = () => {
    if(!peer || !myId){
      toast("Still connecting‚Ä¶ try again in a second.");
      return;
    }
    role = "host";
    roomCode = makeCode(5);

    // Share link: #CODE.PEERID
    const share = `${location.origin}${location.pathname}#${roomCode}.${myId}`;
    history.replaceState(null,"",share);

    ui.room.value = share; // convenient copy
    ui.roomChip.textContent = `room: ${roomCode}`;
    ui.roleChip.textContent = "role: host";
    ui.peerChip.textContent = "peer: ‚Äî";
    toast(`Room code: ${roomCode}`);
    toast("Share the link in the address bar (or the room box).");
    logChat(`‚Ä¢ System: hosting room ${roomCode}. Share the link to join.`);

    ui.btnLeave.disabled = false;
    ui.gameTitle.textContent = "Lobby";
    ui.gameSubtitle.textContent = "Waiting for a player‚Ä¶";
  };

  ui.btnJoin.onclick = () => {
    if(!peer || !myId){
      toast("Still connecting‚Ä¶ try again in a second.");
      return;
    }

    const raw = (ui.room.value || "").trim();
    const hash = (location.hash || "").replace("#","").trim();

    // Accept:
    // - full link: https://.../#CODE.PEERID
    // - token: CODE.PEERID
    // - hash already present: #CODE.PEERID
    let token = "";
    if(raw.includes("#")) token = raw.split("#").pop().trim();
    else if(raw.includes(".")) token = raw.trim();
    else if(hash.includes(".")) token = hash;

    if(!token || !token.includes(".")){
      toast("Paste the host link (preferred) or token CODE.PEERID");
      return;
    }

    const parts = token.split(".");
    roomCode = parts[0];
    const target = parts.slice(1).join(".");
    role = "client";

    ui.roleChip.textContent = "role: client";
    ui.roomChip.textContent = `room: ${roomCode}`;
    ui.peerChip.textContent = `peer: ${target.slice(0,6)}‚Ä¶`;

    const c = peer.connect(target, { reliable: true });
    attachConn(c);
    toast("Joining‚Ä¶");
  };

  ui.btnLeave.onclick = () => {
    if(conn){ try{ conn.close(); }catch(e){} }
    onLeaveCleanup();
  };

  ui.btnSend.onclick = sendChat;
  ui.chatin.addEventListener("keydown", (e) => {
    if(e.key === "Enter") sendChat();
  });

  function sendChat(){
    const text = ui.chatin.value.trim();
    if(!text) return;
    ui.chatin.value = "";
    const nick = (ui.nick.value || "Me").slice(0,16);
    logChat(`‚Ä¢ ${nick}: ${text}`);
    send({ type:"chat", nick, text });
  }

  function hostOnlyGuard(){
    if(connected && role !== "host"){
      toast("Only host can do that.");
      return false;
    }
    return true;
  }

  ui.pickPong.onclick = () => { if(hostOnlyGuard()) setGame("pong"); };
  ui.pickTag.onclick  = () => { if(hostOnlyGuard()) setGame("tag"); };
  ui.pickRace.onclick = () => { if(hostOnlyGuard()) setGame("race"); };

  ui.btnReady.onclick = () => {
    if(!connected){
      toast("Connect to a room first.");
      return;
    }
    if(role === "host"){
      ready.host = !ready.host;
      send({ type:"ready", who:"host", v: ready.host });
      toast(ready.host ? "Host ready!" : "Host not ready");
      startRoundIfReady();
    }else if(role === "client"){
      ready.client = !ready.client;
      send({ type:"ready", who:"client", v: ready.client });
      toast(ready.client ? "Client ready!" : "Client not ready");
    }
  };

  ui.btnReset.onclick = () => {
    if(!connected){ toast("Connect first."); return; }
    resetRound();
  };

  function setParty(v){
    partyMode = !!v;
    ui.partyChip.textContent = `party: ${partyMode ? "ON" : "OFF"}`;
    ui.btnParty.textContent = `Party mode: ${partyMode ? "ON" : "OFF"}`;
  }

  ui.btnParty.onclick = () => {
    if(!hostOnlyGuard()) return;
    setParty(!partyMode);
    toast(partyMode ? "Party mode ON (games rotate!)" : "Party mode OFF");
    send({ type:"party", v: partyMode });
  };
  ui.btnPartyTile.onclick = () => ui.btnParty.click();

  ui.btnRandom.onclick = () => {
    if(!hostOnlyGuard()) return;
    const g = gamesList[(Math.random()*gamesList.length)|0];
    setGame(g);
  };

  // =========================================================
  // Input handling
  // =========================================================
  const key = {};
  window.addEventListener("keydown", (e) => {
    if(e.key === "Escape" && connected) ui.btnLeave.click();
    if(e.key.toLowerCase() === "r" && connected) ui.btnReady.click();
    key[e.key.toLowerCase()] = true;
    updateInputsFromKeys();
  });
  window.addEventListener("keyup", (e) => {
    key[e.key.toLowerCase()] = false;
    updateInputsFromKeys();
  });

  function updateInputsFromKeys(){
    const dash = !!key[" "] || !!key["space"];
    const localI = {
      up: !!key["w"] || !!key["arrowup"],
      down: !!key["s"] || !!key["arrowdown"],
      left: !!key["a"] || !!key["arrowleft"],
      right: !!key["d"] || !!key["arrowright"],
      dash
    };

    if(!connected){
      input.host = localI;
      input.client = {
        up: !!key["i"],
        down: !!key["k"],
        left: !!key["j"],
        right: !!key["l"],
        dash: !!key["shift"]
      };
      return;
    }

    if(role === "host"){
      input.host = localI;
    }else{
      input.client = localI;
      send({ type:"input", v: input.client });
    }
  }

  // Mobile buttons
  function bindHold(btn, onDown, onUp){
    const down = (e)=>{ e.preventDefault(); onDown(); };
    const up = (e)=>{ e.preventDefault(); onUp(); };
    btn.addEventListener("touchstart", down, {passive:false});
    btn.addEventListener("mousedown", down);
    window.addEventListener("touchend", up, {passive:false});
    window.addEventListener("mouseup", up);
  }

  const m = { left: $("mLeft"), right:$("mRight"), up:$("mUp"), down:$("mDown"), dash:$("mDash") };
  const mState = {left:false,right:false,up:false,down:false,dash:false};

  bindHold(m.left, ()=>{mState.left=true; pushMobile();}, ()=>{mState.left=false; pushMobile();});
  bindHold(m.right,()=>{mState.right=true;pushMobile();},()=>{mState.right=false;pushMobile();});
  bindHold(m.up,   ()=>{mState.up=true;   pushMobile();},()=>{mState.up=false;   pushMobile();});
  bindHold(m.down, ()=>{mState.down=true; pushMobile();},()=>{mState.down=false; pushMobile();});
  bindHold(m.dash, ()=>{mState.dash=true; pushMobile();},()=>{mState.dash=false; pushMobile();});

  function pushMobile(){
    if(!connected) return;
    const localI = {...mState};
    if(role === "host") input.host = localI;
    else { input.client = localI; send({ type:"input", v: input.client }); }
  }

  if(("ontouchstart" in window) || navigator.maxTouchPoints > 0){
    ui.mobilePad.style.display = "flex";
  }

  // Hash autofill
  (function autoFillFromHash(){
    const h = (location.hash||"").replace("#","").trim();
    if(h && h.includes(".")){
      ui.room.value = `${location.origin}${location.pathname}#${h}`;
      toast("Link detected. Click Join room.");
    }
  })();

  // initial UI state
  ui.roleChip.textContent = "role: ‚Äî";
  ui.roomChip.textContent = "room: ‚Äî";
  ui.peerChip.textContent = "peer: ‚Äî";
  ui.pingChip.textContent = "ping: ‚Äî";
  setParty(false);

  ui.nick.value = (localStorage.getItem("aa_nick") || "");
  ui.nick.addEventListener("input", ()=>localStorage.setItem("aa_nick", ui.nick.value.slice(0,16)));
  </script>
</body>
</html>
